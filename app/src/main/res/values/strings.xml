<resources>
    <string name="app_name">随身数据库学习</string>
    <string name="introduction_title">前言</string>
    <string name="introduction"> \n\t\t这是一个帮助你学习数据库相关知识的app，我搜罗了网上的一些相关教程，以及一些官方说明，并把他们整理在了一起，按章节划分。\n
    \t\t你可以在闲暇的时候掏出手机来，进行数据库的学习。并且，通过本应用，可以操作安卓系统内置的sqlite数据库，虽然这是一个轻量的数据库，但是使用它来练习增删改查等一些基本操作也是足够了。\n
        \t\t大多数转载的内容都写上了出处，有少部分文章经过多次转载，已经没法查明出处，如果你是这些文章的作者，请联系我，我会删除这些内容。\n
        \n\t\t可能这个应用有很多反人类的设计，并且我没有发现它们，如果你发现了这种反人类设计，请告诉我，我会尽快改正的。
    </string>
    <string name="index">目录</string>
    <string name="start_screen">开始界面</string>
    <string name="start_study">开始学习</string>
    <string name="database_training">数据库练习</string>
    <string name="contactus">联系我们</string>
    <string name="marking">评价此应用</string>
    <string name="result">结果显示</string>
    <string name="title_activity_index">目录</string>
    <string name="introduce">\n\n\t\t\t\t如果本应用转载的文章侵犯了您的版权，请联系我，我会尽快删除</string>
    <string-array name="index">
        <item>序章：数据库概论</item>
        <item>1.1 sql基本数据类型</item>
        <item>1.2 创建库、表、索引</item>
        <item>1.3 数据库完整性约束</item>
        <item>1.4 增删改查</item>
        <item>2.1 视图</item>
        <item>2.2 视图</item>
        <item>3.1 关系数据库规范化理论</item>
        <item>3.2 函数依赖</item>
        <item>3.3 关系规范化</item>
        <item>4.1 事务</item>
        <item>4.2 并发控制</item>
        <item>5.1 存储过程</item>
    </string-array>
    <string-array name="index_to_html">
        <item>zero</item>
        <item>one.1</item>
        <item>one.2</item>
        <item>one.3</item>
        <item>one.4</item>
        <item>two.1</item>
        <item>two.2</item>
        <item>three.1</item>
        <item>three.2</item>
        <item>three.3</item>
        <item>four.1</item>
        <item>four.2</item>
        <item>five.1</item>
    </string-array>
    <string name="chapter_zero">序章：数据库概论</string>
    <string name="chapter_one_1">1.1 sql基本数据类型</string>
    <string name="chapter_one_2">1.2 创建库、表、索引</string>
    <string name="chapter_one_3">1.3 数据库完整性约束</string>
    <string name="chapter_one_4">1.4 增删改查</string>
    <string name="chapter_two_0">2.0 视图</string>
    <string name="chapter_two_1">2.1 视图</string>
    <string name="chapter_three_0">3.0 关系数据库规范化理论</string>
    <string name="chapter_three_1">3.1 函数依赖</string>
    <string name="chapter_three_2">3.2 关系规范化</string>
    <string name="chapter_four_1">4.1 事务</string>
    <string name="chapter_four_2">4.2 并发控制</string>
    <string name="chapter_five_1">5.1 存储过程</string>
    <string name="chapter_content_zero"><![CDATA[
<span>&nbsp; &nbsp; &nbsp; &nbsp; 数据库(Database)是按照数据结构来组织、存储和管理数据的仓库，它产生于距今六十多年前，随着信息技术和市场的发展，特别是二十世纪九十年代以后，数据管理不再仅仅是存储和管理数据，而转变成用户所需要的各种数据管理的方式。数据库有很多种类型，从最简单的存储有各种数据的表格到能够进行海量数据存储的大型数据库系统都在各个方面得到了广泛的应用。 在信息化社会，充分有效地管理和利用各类信息资源，是进行科学研究和决策管理的前提条件。数据库技术是管理信息系统、办公自动化系统、决策支持系统等各类信息系统的核心部分，是进行科学研究和决策管理的重要技术手段。 &nbsp;</span><h2>定义</h2><h5>定义1</h5><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; 数据库(Database)是按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库。 &nbsp; 简单来说是本身可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据进行新增、截取、更新、删除等操作。 &nbsp; 在经济管理的日常工作中，常常需要把某些相关的数据放进这样的“仓库”，并根据管理的需要进行相应的处理。 &nbsp; 例如，企业或事业单位的人事部门常常要把本单位职工的基本情况(职工号、姓名、年龄、性别、籍贯、工资、简历等)存放在表中，这张表就可以看成是一个数据库。有了这个"数据仓库"我们就可以根据需要随时查询某职工的基本情况，也可以查询工资在某个范围内的职工人数等等。这些工作如果都能在计算机上自动进行，那我们的人事管理就可以达到极高的水平。此外，在财务管理、仓库管理、生产管理中也需要建立众多的这种"数据库"，使其可以利用计算机实现财务、仓库、生产的自动化管理。 &nbsp;</span><h5>定义2</h5><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; 严格来说，数据库是长期储存在计算机内、有组织的、可共享的数据集合。数据库中的数据指的是以一定的数据模型组织、描述和储存在一起、具有尽可能小的冗余度、较高的数据独立性和易扩展性的特点并可在一定范围内为多个用户共享。 &nbsp; 这种数据集合具有如下特点：尽可能不重复，以最优方式为某个特定组织的多种应用服务，其数据结构独立于使用它的应用程序，对数据的增、删、改、查由统一软件进行管理和控制。从发展的历史看，数据库是数据管理的高级阶段，它是由文件管理系统发展起来的。 &nbsp;</span><h2>处理系统</h2><span>&nbsp; &nbsp; &nbsp; &nbsp; 数据库是一个单位或是一个应用领域的通用数据处理系统，它存储的是属于企业和事业部门、团体和个人的有关数据的集合。数据库中的数据是从全局观点出发建立的，按一定的数据模型进行组织、描述和存储。其结构基于数据间的自然联系，从而可提供一切必要的存取路径，且数据不再针对某一应用，而是面向全组织，具有整体的结构化特征。 &nbsp; 数据库中的数据是为众多用户所共享其信息而建立的，已经摆脱了具体程序的限制和制约。不同的用户可以按各自的用法使用数据库中的数据；多个用户可以同时共享数据库中的数据资源，即不同的用户可以同时存取数据库中的同一个数据。数据共享性不仅满足了各用户对信息内容的要求，同时也满足了各用户之间信息通信的要求。 &nbsp;</span><h2>基本结构</h2><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; 数据库的基本结构分三个层次，反映了观察数据库的三种不同角度。 &nbsp; 以内模式为框架所组成的数据库叫做物理数据库；以概念模式为框架所组成的数据叫概念数据库；以外模式为框架所组成的数据库叫用户数据库。 &nbsp; ⑴ 物理数据层。 &nbsp; &nbsp;&nbsp;&nbsp; 它是数据库的最内层，是物理存贮设备上实际存储的数据的集合。这些数据是原始数据，是用户加工的对象，由内部模式描述的指令操作处理的位串、字符和字组成。&nbsp;&nbsp;&nbsp; ⑵ 概念数据层。 &nbsp; &nbsp;&nbsp;&nbsp; 它是数据库的中间一层，是数据库的整体逻辑表示。指出了每个数据的逻辑定义及数据间的逻辑联系，是存贮记录的集合。它所涉及的是数据库所有对象的逻辑关系，而不是它们的物理情况，是数据库管理员概念下的数据库。 &nbsp; ⑶ 用户数据层。 &nbsp;&nbsp;&nbsp; 它是用户所看到和使用的数据库，表示了一个或一些特定用户使用的数据集合，即逻辑记录的集合。 &nbsp; 数据库不同层次之间的联系是通过映射进行转换的。 &nbsp;</span><h2>主要特点</h2><p><span>⑴ 实现数据共享</span></p><p><span>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;数据共享包含所有用户可同时存取数据库中的数据，也包括用户可以用各种方式通过接口使用数据库，并提供数据共享。&nbsp;&nbsp;&nbsp; ⑵ 减少数据的冗余度 &nbsp; &nbsp;&nbsp;&nbsp; 同文件系统相比，由于数据库实现了数据共享，从而避免了用户各自建立应用文件。减少了大量重复数据，减少了数据冗余，维护了数据的一致性。 &nbsp; ⑶ 数据的独立性 &nbsp;&nbsp;&nbsp; 数据的独立性包括逻辑独立性（数据库中数据库的逻辑结构和应用程序相互独立）和物理独立性（数据物理结构的变化不影响数据的逻辑结构）。 &nbsp; ⑷ 数据实现集中控制 &nbsp;&nbsp;&nbsp; 文件管理方式中，数据处于一种分散的状态，不同的用户或同一用户在不同处理中其文件之间毫无关系。利用数据库可对数据进行集中控制和管理，并通过数据模型表示各种数据的组织以及数据间的联系。 ⑸数据一致性和可维护性，以确保数据的安全性和可靠性 &nbsp;&nbsp; 主要包括： &nbsp;&nbsp; ①安全性控制：以防止数据丢失、错误更新和越权使用； &nbsp;&nbsp; ②完整性控制：保证数据的正确性、有效性和相容性； &nbsp;&nbsp; ③并发控制：使在同一时间周期内，允许对数据实现多路存取，又能防止用户之间的不正常交互作用。 &nbsp; ⑹ 故障恢复 &nbsp;&nbsp;&nbsp; 由数据库管理系统提供一套方法，可及时发现故障和修复故障，从而防止数据被破坏。数据库系统能尽快恢复数据库系统运行时出现的故障，可能是物理上或是逻辑上的错误。比如对系统的误操作造成的数据错误等。 &nbsp;</span></p><h2>数据种类</h2><span>&nbsp; 数据库通常分为层次式数据库、网络式数据库和关系式数据库三种。而不同的数据库是按不同的数据结构来联系和组织的。</span><h5>1.数据结构模型</h5><p><span>⑴数据结构</span></p><p><span>&nbsp;&nbsp;&nbsp; 所谓数据结构是指数据的组织形式或数据之间的联系。 &nbsp; 如果用D表示数据，用R表示数据对象之间存在的关系集合，则将DS=(D，R)称为数据结构。 &nbsp; 例如，设有一个电话号码簿，它记录了n个人的名字和相应的电话号码。为了方便地查找某人的电话号码，将人名和号码按字典顺序排列，并在名字的后面跟随着对应的电话号码。这样，若要查找某人的电话号码(假定他的名字的第一个字母是Y)，那么只须查找以Y开头的那些名字就可以了。该例中，数据的集合D就是人名和电话号码，它们之间的联系R就是按字典顺序的排列，其相应的数据结构就是DS=(D，R)，即一个数组。</span></p><p><span>⑵数据结构类型</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp; 数据结构又分为数据的逻辑结构和数据的物理结构。 &nbsp; 数据的逻辑结构是从逻辑的角度(即数据间的联系和组织方式)来观察数据，分析数据，与数据的存储位置无关；数据的物理结构是指数据在计算机中存放的结构，即数据的逻辑结构在计算机中的实现形式，所以物理结构也被称为存储结构。 &nbsp; 这里只研究数据的逻辑结构，并将反映和实现数据联系的方法称为数据模型。 &nbsp; 比较流行的数据模型有三种，即按图论理论建立的层次结构模型和网状结构模型以及按关系理论建立的关系结构模型。</span></p><h5>2.层次、网状和关系数据库系统</h5><p><span>⑴层次结构模型</span></p><p><span>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 层次结构模型实质上是一种有根结点的定向有序树(在数学中"树"被定义为一个无回的连通图)。比如一个高等学校的组织结构图。这个组织结构图像一棵树，校部就是树根(称为根结点)，各系、专业、教师、学生等为枝点(称为结点)，树根与枝点之间的联系称为边，树根与边之比为1:N，即树根只有一个，树枝有N个。 &nbsp; 按照层次模型建立的数据库系统称为层次模型数据库系统。IMS(Information Management System)是其典型代表。</span></p><p><span>⑵网状结构模型&nbsp;</span></p><p><span>&nbsp; &nbsp; &nbsp;&nbsp;</span>按照网状数据结构建立的数据库系统称为网状数据库系统，其典型代表是DBTG(Database Task Group)。用数学方法可将网状数据结构转化为层次数据结构。</p><p>&nbsp;⑶ 关系结构模型</p><p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 关系式数据结构把一些复杂的数据结构归结为简单的二元关系(即二维表格形式)。例如某单位的职工关系就是一个二元关系。 &nbsp; 由关系数据结构组成的数据库系统被称为关系数据库系统。 &nbsp; 在关系数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关系表格的分类、合并、连接或选取等运算来实现数据的管理。 &nbsp; dBASEⅡ就是这类数据库管理系统的典型代表。对于一个实际的应用问题（如人事管理问题），有时需要多个关系才能实现。用dBASEⅡ建立起来的一个关系称为一个数据库（或称数据库文件），而把对应多个关系建立起来的多个数据库称为数据库系统。dBASEⅡ的另一个重要功能是通过建立命令文件来实现对数据库的使用和管理，对于一个数据库系统相应的命令序列文件，称为该数据库的应用系统。 &nbsp; 因此，可以概括地说，一个关系称为一个数据库，若干个数据库可以构成一个数据库系统。数据库系统可以派生出各种不同类型的辅助文件和建立它的应用系统。</p><h2>发展简史</h2><h5>技术发展</h5><span>&nbsp; &nbsp; &nbsp; &nbsp; 使用计算机后，随着数据处理量的增长，产生了数据管理技术。数据管理技术的发展与计算机硬件（主要是外部存储器）系统软件及计算机应用的范围有着密切的联系。数据管理技术的发展经历了以下四个阶段：人工管理阶段、文件系统阶段、数据库阶段和高级数据库技术阶段。 &nbsp; 数据管理的诞生 &nbsp; 数据库的历史可以追溯到五十年前，那时的数据管理非常简单。通过大量的分类、比较和表格绘制的机器运行数百万穿孔卡片来进行数据的处理，其运行结果在纸上打印出来或者制成新的穿孔卡片。而数据管理就是对所有这些穿孔卡片进行物理的储存和处理。然而，1950 年雷明顿兰德公司（Remington Rand Inc）的一种叫做Univac I 的计算机推出了一种一秒钟可以输入数百条记录的磁带驱动器，从而引发了数据管理的革命。1956 年IBM生产出第一个磁盘驱动器—— the Model 305 RAMAC。此驱动器有50 个盘片，每个盘片直径是2 英尺，可以储存5MB的数据。使用磁盘最大的好处是可以随机存取数据，而穿孔卡片和磁带只能顺序存取数据。 &nbsp; 1951： Univac系统使用磁带和穿孔卡片作为数据存储。 &nbsp; 数据库系统的萌芽出现于二十世纪60 年代。当时计算机开始广泛地应用于数据管理，对数据的共享提出了越来越高的要求。传统的文件系统已经不能满足人们的需要，能够统一管理和共享数据的数据库管理系统（DBMS）应运而生。数据模型是数据库系统的核心和基础，各种DBMS软件都是基于某种数据模型的。所以通常也按照数据模型的特点将传统数据库系统分成网状数据库、层次数据库和关系数据库三类。 &nbsp; 最早出现的网状DBMS，是美国通用电气公司Bachman等人在1961年开发的IDS（Integrated Data Store）。1964年通用电气公司（General ElectricCo.）的Charles Bachman 成功地开发出世界上第一个网状DBMS也即第一个数据库管理系统——集成数据存储（Integrated Data Store IDS），奠定了网状数据库的基础，并在当时得到了广泛的发行和应用。IDS 具有数据模式和日志的特征，但它只能在GE主机上运行，并且数据库只有一个文件，数据库所有的表必须通过手工编码生成。之后，通用电气公司一个客户——BF Goodrich Chemical 公司最终不得不重写了整个系统，并将重写后的系统命名为集成数据管理系统（IDMS）。 &nbsp; 网状数据库模型对于层次和非层次结构的事物都能比较自然的模拟，在关系数据库出现之前网状DBMS要比层次DBMS用得普遍。在数据库发展史上，网状数据库占有重要地位。 &nbsp; 层次型DBMS是紧随网络型数据库而出现的，最著名最典型的层次数据库系统是IBM 公司在1968 年开发的IMS（Information Management System），一种适合其主机的层次数据库。这是IBM公司研制的最早的大型数据库系统程序产品。从60年代末产生起，如今已经发展到IMSV6，提供群集、N路数据共享、消息队列共享等先进特性的支持。这个具有30年历史的数据库产品在如今的WWW应用连接、商务智能应用中扮演着新的角色。 &nbsp; 1973年Cullinane公司（也就是后来的Cullinet软件公司），开始出售Goodrich公司的IDMS改进版本，并且逐渐成为当时世界上最大的软件公司。 &nbsp;</span><h5>关系由来</h5><span>&nbsp; &nbsp; &nbsp; &nbsp; 网状数据库和层次数据库已经很好地解决了数据的集中和共享问题，但是在数据独立性和抽象级别上仍有很大欠缺。用户在对这两种数据库进行存取时，仍然需要明确数据的存储结构，指出存取路径。而后来出现的关系数据库较好地解决了这些问题。 &nbsp; 1970年，IBM的研究员E.F.Codd博士在刊物《Communication of the ACM》上发表了一篇名为“A Relational Model of Data for Large Shared Data Banks”的论文，提出了关系模型的概念，奠定了关系模型的理论基础。尽管之前在1968年Childs已经提出了面向集合的模型，然而这篇论文被普遍认为是数据库系统历史上具有划时代意义的里程碑。Codd的心愿是为数据库建立一个优美的数据模型。后来Codd又陆续发表多篇文章，论述了范式理论和衡量关系系统的12条标准，用数学理论奠定了关系数据库的基础。关系模型有严格的数学基础，抽象级别比较高，而且简单清晰，便于理解和使用。但是当时也有人认为关系模型是理想化的数据模型，用来实现DBMS是不现实的，尤其担心关系数据库的性能难以接受，更有人视其为当时正在进行中的网状数据库规范化工作的严重威胁。为了促进对问题的理解，1974年ACM牵头组织了一次研讨会，会上开展了一场分别以Codd和Bachman为首的支持和反对关系数据库两派之间的辩论。这次著名的辩论推动了关系数据库的发展，使其最终成为现代数据库产品的主流。 &nbsp; 1969年Edgar F.“Ted” Codd发明了关系数据库。 &nbsp; 1970年关系模型建立之后，IBM公司在San Jose实验室增加了更多的研究人员研究这个项目，这个项目就是著名的System R。其目标是论证一个全功能关系DBMS的可行性。该项目结束于1979年，完成了第一个实现SQL的 DBMS。然而IBM对IMS的承诺阻止了System R的投产，一直到1980年System R才作为一个产品正式推向市场。IBM产品化步伐缓慢的三个原因：IBM重视信誉，重视质量，尽量减少故障；IBM是个大公司，官僚体系庞大，IBM内部已经有层次数据库产品，相关人员不积极，甚至反对。 &nbsp; 然而同时，1973年加州大学伯克利分校的Michael Stonebraker和Eugene Wong利用System R已发布的信息开始开发自己的关系数据库系统Ingres。他们开发的Ingres项目最后由Oracle公司、Ingres公司以及硅谷的其他厂商所商品化。后来，System R和Ingres系统双双获得ACM的1988年“软件系统奖”。 &nbsp; 1976年霍尼韦尔公司(Honeywell)开发了第一个商用关系数据库系统——Multics Relational Data Store。关系型数据库系统以关系代数为坚实的理论基础，经过几十年的发展和实际应用，技术越来越成熟和完善。其代表产品有Oracle、IBM公司的 DB2、微软公司的MS SQL Server以及Informix、ADABAS D等等。 &nbsp;&nbsp;</span><h5>结构语言</h5><span>&nbsp; &nbsp; &nbsp; &nbsp; 1974年IBM的Ray Boyce和Don Chamberlin将Codd关系数据库的12条准则的数学定义以简单的关键字语法表现出来，里程碑式地提出了SQL(Structured Query Language)语言。SQL语言的功能包括查询、操纵、定义和控制，是一个综合的、通用的关系数据库语言，同时又是一种高度非过程化的语言，只要求用户指出做什么而不需要指出怎么做。SQL集成实现了数据库生命周期中的全部操作。SQL提供了与关系数据库进行交互的方法，它可以与标准的编程语言一起工作。自产生之日起，SQL语言便成了检验关系数据库的试金石，而SQL语言标准的每一次变更都指导着关系数据库产品的发展方向。然而，直到二十世纪七十年代中期，关系理论才通过SQL在商业数据库Oracle和DB2中使用。 &nbsp; 1986年，ANSI把SQL作为关系数据库语言的美国标准，同年公布了标准SQL文本。SQL标准有3个版本。基本SQL定义是ANSⅨ3135-89，“Database Language - SQL with Integrity Enhancement”[ANS89]，一般叫做SQL-89。SQL-89定义了模式定义、数据操作和事务处理。SQL- 89和随后的ANSⅨ3168-1989，“Database Language-Embedded SQL”构成了第一代SQL标准。ANSⅨ3135-1992[ANS92]描述了一种增强功能的SQL，叫做SQL-92标准。SQL-92包括模式操作，动态创建和SQL语句动态执行、网络环境支持等增强特性。在完成SQL-92标准后，ANSI和ISO即开始合作开发SQL3标准。SQL3的主要特点在于抽象数据类型的支持，为新一代对象关系数据库提供了标准。 &nbsp; 1976年IBM E.F.Codd发表了一篇里程碑的论文“R系统：数据库关系理论”，介绍了关系数据库理论和查询语言SQL。Oracle的创始人Ellison非常仔细地阅读了这篇文章，被其内容震惊，这是第一次有人用全面一致的方案管理数据信息。作者E.F.Codd 1966年就发表了关系数据库理论，并在IBM研究机构开发原型，这个项目就是R系统，存取数据表的语言就是SQL。Ellison看完后，敏锐意识到在这个研究基础上可以开发商用软件系统。而当时大多数人认为关系数据库不会有商业价值。Ellison认为这是他们的机会：他们决定开发通用商用数据库系统Oracle，这个名字来源于他们曾给中央情报局做过的项目名。几个月后，他们就开发了Oracle 1.0。但这只不过是个玩具，除了完成简单关系查询不能做任何事情，他们花相当长的时间才使Oracle变得可用，维持公司运转主要靠承接一些数据库管理项目和做顾问咨询工作。而IBM却没有计划开发，为什么蓝色巨人放弃了这个价值上百亿的产品，原因有很多：IBM的研究人员大多是学术出身，他们最感兴趣的是理论，而非推向市场的产品，从学术上看，研究成果应公开发表论文和演讲能使他们成名，为什么不呢？还有一个很主要的原因就是IBM当时有一个销售得还不错的层次数据库产品IMS。直到1985年IBM才发布了关系数据库DB2 ，Ellision那时已经成了千万富翁。Ellison曾将IBM 选择Microsoft 的MS-DOS作为IBM-PC机的操作系统比为：“世界企业经营历史上最严重的错误，价值超过了上千亿美元。”IBM发表R系统论文，而且没有很快推出关系数据库产品的错误可能仅仅次之。Oracle的市值在1996年就达到了280亿美元。</span><h5>对象数据</h5><span>&nbsp; &nbsp; &nbsp; &nbsp; 随着信息技术和市场的发展，人们发现关系型数据库系统虽然技术很成熟，但其局限性也是显而易见的：它能很好地处理所谓的“表格型数据”，却对技术界出现的越来越多的复杂类型的数据无能为力。九十年代以后，技术界一直在研究和寻求新型数据库系统。但在什么是新型数据库系统的发展方向的问题上，产业界一度是相当困惑的。受当时技术风潮的影响，在相当一段时间内，人们把大量的精力花在研究“面向对象的数据库系统(object oriented database)”或简称“OO数据库系统”。值得一提的是，美国Stonebraker教授提出的面向对象的关系型数据库理论曾一度受到产业界的青睐。而Stonebraker本人也在当时被Informix花大价钱聘为技术总负责人。 &nbsp; 然而，数年的发展表明，面向对象的关系型数据库系统产品的市场发展的情况并不理想。理论上的完美性并没有带来市场的热烈反应。其不成功的主要原因在于，这种数据库产品的主要设计思想是企图用新型数据库系统来取代现有的数据库系统。这对许多已经运用数据库系统多年并积累了大量工作数据的客户，尤其是大客户来说，是无法承受新旧数据间的转换而带来的巨大工作量及巨额开支的。另外，面向对象的关系型数据库系统使查询语言变得极其复杂，从而使得无论是数据库的开发商家还是应用客户都视其复杂的应用技术为畏途。</span><h5>管理变革</h5><span>&nbsp; &nbsp; &nbsp; &nbsp; 二十世纪六十年代后期出现了一种新型数据库软件：决策支持系统(DSS)，其目的是让管理者在决策过程中更有效地利用数据信息。于是在1970年，第一个联机分析处理工具——Express诞生了。其他决策支持系统紧随其后，许多是由公司的IT部门开发出来的。 &nbsp; 1985年，第一个商务智能系统(business intelligence)由Metaphor计算机系统有限公司为Procter &amp; Gamble公司开发出来，主要是用来连接销售信息和零售的扫描仪数据。同年， Pilot软件公司开始出售第一个商用客户/服务器执行信息系统——Command Center。同样在这年，加州大学伯克利分校Ingres项目演变成Postgres，其目标是开发出一个面向对象的数据库。此后一年， Graphael公司开发了第一个商用的对象数据库系统—Gbase。 &nbsp; 1988年，IBM公司的研究者Barry Devlin和Paul Murphy发明了一个新的术语—信息仓库，之后，IT的厂商开始构建实验性的数据仓库。1991年，W.H. "Bill" Inmon出版了一本“如何构建数据仓库”的书，使得数据仓库真正开始应用。 &nbsp; 1991： W.H.“Bill” Inmon发表了”构建数据仓库” &nbsp; 二十世纪九十年代，随着基于PC的客户/服务器计算模式和企业软件包的广泛采用，数据管理的变革基本完成。数据管理不再仅仅是存储和管理数据，而转变成用户所需要的各种数据管理的方式。Internet的异军突起以及XML语言的出现，给数据库系统的发展开辟了一片新的天地。 &nbsp;</span><h2>发展阶段</h2><span>数据库发展阶段大致划分为如下的几个阶段：人工管理阶段、文件系统阶段、数据库系统阶段、高级数据库阶段。 &nbsp;</span><h5>人工管理阶段</h5><br /><span>&nbsp; &nbsp; &nbsp; &nbsp; 20世纪50年代中期之前，计算机的软硬件均不完善。硬件存储设备只有磁带、卡片和纸带，软件方面还没有操作系统，当时的计算机主要用于科学计算。这个阶段由于还没有软件系统对数据进行管理，程序员在程序中不仅要规定数据的逻辑结构，还要设计其物理结构，包括存储结构、存取方法、输入输出方式等。当数据的物理组织或存储设备改变时，用户程序就必须重新编制。由于数据的组织面向应用，不同的计算程序之间不能共享数据，使得不同的应用之间存在大量的重复数据，很难维护应用程序之间数据的一致性。 &nbsp; 这一阶段的主要特征可归纳为如下几点： &nbsp; （1）计算机中没有支持数据管理的软件，计算机系统不提供对用户数据的管理功能，应用程序只包含自己要用到的全部数据。用户编制程序，必须全面考虑好相关的数据，包括数据的定义、存储结构以即存取方法等。程序和数据是一个不可分割的整体。数据脱离了程序极具无任何存在的价值，数据无独立性。 &nbsp; （2）数据不能共享。不同的程序均有各自的数据，这些数据对不同的程序通常是不相同的，不可共享；即使不同的程序使用了相同的一组数据，这些数据也不能共享，程序中仍然需要各自加入这组数据，哪个部分都不能省略。基于这种数据的不可共享性，必然导致程序与程序之间存在大量的重复数据，浪费存储空间。 &nbsp; （3）不能单独保存数据。在程序中要规定数据的逻辑结构和物理结构，数据与程序不独立。基于数据与程序是一个整体，数据只为本程序所使用，数据只有与相应的程序一起保存才有价值，否则毫无用处。所以，所有程序的数据不单独保存。数据处理的方式是批处理。 &nbsp;</span><h5>文件系统阶段</h5><span>&nbsp; &nbsp; &nbsp; &nbsp; 这一阶段的主要标志是计算机中有了专门管理数据库的软件——操作系统（文件管理）。 &nbsp; 上世纪50年代中期到60年代中期，由于计算机大容量直接存储设备如硬盘、磁鼓的出现， &nbsp; 推动了软件技术的发展，软件的领域出现了操作系统和高级软件，操作系统中的文件系统是专门管理外存的数据管理软件，操作系统为用户使用文件提供了友好界面。操作系统的出现标志着数据管理步入一个新的阶段。在文件系统阶段，数据以文件为单位存储在外存，且由操作系统统一管理，文件是操作系统管理的重要资源。 &nbsp; 文件系统阶段的数据管理具有一下几个特点： &nbsp;</span><h5>优点</h5><p><span>（1）数据以“文件”形式可长期保存在外部存储器的磁盘上。由于计算机的应用转向信息管理，因此对文件要进行大量的查询、修改和插入等操作。</span></p><p><span>（2）数据的逻辑结构与物理结构有了区别，程序和数据分离，使数据与程序有了一定的独立性，但比较简单。数据的逻辑结构是指呈现在用户面前的数据结构形式。数据的物理结构是指数据在计算机存储设备上的实际存储结构。程度与数据之间具有“设备独立性”，即程序只需用文件名就可与数据打交道，不必关心数据的物理位置。由操作系统的文件系统提供存取方法（读/写）。</span></p><p><span>（3）文件组织已多样化。有索引文件、链接文件和直接存取文件等。但文件之间相互独立、缺乏联系。数据之间的联系需要通过程序去构造。</span></p><p><span>（4）数据不再属于某个特定的程序，可以重复使用，即数据面向应用。但是文件结构的设计仍是基于特定的用途，程序基于特定的物理结构和存取方法，因此程度与数据结构之间的依赖关系并未根本改变。</span></p><p><span>（5）用户的程序与数据可分别存放在外存储器上，各个应用程序可以共享一组数据，实现了以文件为单位的数据共享文件系统。</span></p><p><span>（6）对数据的操作以记录为单位。这是由于文件中只存储数据，不存储文件记录的结构描述信息。文件的建立、存取、查询、插入、删除、修改等操作，都要用程序来实现。 &nbsp; （7）数据处理方式有批处理，也有联机实时处理。</span></p><h5>缺点</h5><p><span>&nbsp; &nbsp; &nbsp; &nbsp; 文件系统对计算机数据管理能力的提高虽然起了很大的作用，但随着数据管理规模的扩大，数据量急剧增加，文价系统显露出一些缺陷，问题表现在： &nbsp;&nbsp;</span></p><p><span>（1）数据文件是为了满足特定业务领域某一部门的专门需要而设计，数据和程序相互依赖，数据缺乏足够的独立性。</span></p><p><span>（2）数据没有集中管理的机制，其安全性和完整性无法保障，数据维护业务仍然由应用程序来承担；</span></p><p><span>（3）数据的组织仍然是面向程序，数据与程序的依赖性强，数据的逻辑结构不能方便地修改和扩充，数据逻辑结构的每一点微小改变都会影响到应用程序；而且文件之间的缺乏联系，因而它们不能反映现实世界中事物之间的联系，加上操作系统不负责维护文件之间的联系，信息造成每个应用程序都有相对应的文件。如果文件之间有内容上的联系，那也只能由应用程序去处理，有可能同样的数据在多个文件中重复储存。这两者造成了大量的数据冗余。</span></p><p><span>（4）对现有数据文件不易扩充，不易移植，难以通过增、删数据项来适应新的应用要求。 &nbsp;</span></p><h5>数据库系统阶段</h5><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;20世纪60年代后期，随着计算机在数据管理领域的普遍应用，人们对数据管理技术提出了更高的要求：希望面向企业或部门，以数据为中心组织数据，减少数据的冗余，提供更高的数据共享能力，同时要求程序和数据具有较高的独立性，当数据的逻辑结构改变时，不涉及数据的物理结构，也不影响应用程序，以降低应用程序研制与维护的费用。数据库技术正是在这样一个应用需求的基础上发展起来的。 &nbsp; 概括起来，数据库系统阶段的数据管理具有以下几个特点： &nbsp; （1）采用数据模型表示复杂的数据结构。数据模型不仅描述数据本身的特征，还要描述数据之间的联系，这种联系通过所有存取路径。通过所有存储路径表示自然的数据联系是数据库与传统文件的根本区别。这样，数据不再面向特定的某个或多个应用，而是面对整个应用系统。如面向企业或部门，以数据为中心组织数据，形成综合性的数据库，为各应用共享。 &nbsp; （2）由于面对整个应用系统使得，数据冗余小，易修改、易扩充，实现了数据贡献。不同的应用程序根据处理要求，从数据库中获取需要的数据，这样就减少了数据的重复存储，也便于增加新的数据结构，便于维护数据的一致性。 &nbsp; （3）对数据进行统一管理和控制，提供了数据的安全性、完整性、以及并发控制。 &nbsp; （4）程序和数据有较高的独立性。数据的逻辑结构与物理结构之间的差别可以很大，用户以简单的逻辑结构操作数据而无须考虑数据的物理结构。 &nbsp; （5）具有良好的用户接口，用户可方便地开发和使用数据库。 &nbsp; 从文件系统发展到数据库系统，这在信息领域中具有里程碑的意义。在文件系统阶段，人们在信息处理中关注的中心问题是系统功能的设计，因此程序设计占主导地位；而在数据库方式下，数据开始占据了中心位置，数据的结构设计成为信息系统首先关心的问题，而应用程序则以既定的数据结构为基础进行设计。</span><h5>发展趋势</h5><span>&nbsp; &nbsp; &nbsp; &nbsp; 随着信息管理内容的不断扩展，出现了丰富多样的数据模型（层次模型，网状模型，关系模型，面向对象模型，半结构化模型等），新技术也层出不穷（数据流，Web数据管理，数据挖掘等）。每隔几年，国际上一些资深的数据库专家就会聚集一堂，探讨数据库研究现状，存在的问题和未来需要关注的新技术焦点。过去已有的几个类似报告包括：1989年Future Directions inDBMS Research-The Laguna BeachParticipants ；1990年DatabaseSystems : Achievements and Opportunities ；1991年W.H. Inmon 发表的《构建数据仓库》；1995年Database。 &nbsp;&nbsp;</span><br /><span>&nbsp;</span>
    ]]>
</string>
    <string name="chapter_content_one_1"><![CDATA[
<div id="maincontent">
    <h1>SQL 数据类型</h1>
<div>
<h2>MySQL 数据类型</h2>
<p>在 MySQL 中，有三种主要的类型：文本、数字和日期/时间类型。</p>
<h3>Text 类型：</h3>
<table class="dataintable">
<tbody><tr>
<th>数据类型</th>
<th>描述</th>
</tr>
<tr>
<td>CHAR(size)</td>
<td>保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。</td>
</tr>
<tr>
<td>VARCHAR(size)</td>
<td>
<p>保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。</p>
<p>注释：如果值的长度大于 255，则被转换为 TEXT 类型。</p>
</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>存放最大长度为 255 个字符的字符串。</td>
</tr>
<tr>
<td>TEXT</td>
<td>存放最大长度为 65,535 个字符的字符串。</td>
</tr>
<tr>
<td>BLOB</td>
<td>用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>存放最大长度为 16,777,215 个字符的字符串。</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>存放最大长度为 4,294,967,295 个字符的字符串。</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。</td>
</tr>
<tr>
<td class="no_wrap">ENUM(x,y,z,etc.)</td>
<td>
<p>允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。</p>
</td>
</tr>
<tr>
<td>SET</td>
<td>与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。</td>
</tr>
</tbody></table>
<h3>Number 类型：</h3>
<table class="dataintable">
<tbody><tr>
<th>数据类型</th>
<th>描述</th>
</tr>
<tr>
<td>TINYINT(size)</td>
<td>-128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。</td>
</tr>
<tr>
<td>SMALLINT(size)</td>
<td>-32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。</td>
</tr>
<tr>
<td>MEDIUMINT(size)</td>
<td>-8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。</td>
</tr>
<tr>
<td>INT(size)</td>
<td>-2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。</td>
</tr>
<tr>
<td>BIGINT(size)</td>
<td>-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。</td>
</tr>
<tr>
<td>FLOAT(size,d)</td>
<td>带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>DOUBLE(size,d)</td>
<td>带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>DECIMAL(size,d)</td>
<td>作为字符串存储的 DOUBLE 类型，允许固定的小数点。</td>
</tr>
</tbody></table>
<p>* 这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。</p>
<h3>Date 类型：</h3>
<table class="dataintable">
<tbody><tr>
<th>数据类型</th>
<th>描述</th>
</tr>
<tr>
<td>DATE()</td>
<td>
<p>日期。格式：YYYY-MM-DD</p>
</td>
</tr>
<tr>
<td>DATETIME()</td>
<td>
</td>
</tr>
<tr>
<td class="no_wrap">TIMESTAMP()</td>
<td>
<p>*时间戳。TIMESTAMP 值使用 Unix 纪元 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS</p>
</td>
</tr>
<tr>
<td>TIME()</td>
<td>
时间。格式：HH:MM:SS
</td>
</tr>
<tr>
<td>YEAR()</td>
<td>
<p>2 位或 4 位格式的年。</p>
<p>注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。</p>
</td>
</tr>
</tbody></table>
<p>* 即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。</p>
</div>
<div>
<h2>SQL Server 数据类型</h2>
<h3>Character 字符串：</h3>
<table class="dataintable">
<tbody><tr>
<th>数据类型</th>
<th>描述</th>
<th>存储</th>
</tr>
<tr>
<td>char(n)</td>
<td>固定长度的字符串。最多 8,000 个字符。</td>
<td>n</td>
</tr>
<tr>
<td>varchar(n)</td>
<td>可变长度的字符串。最多 8,000 个字符。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>varchar(max)</td>
<td>可变长度的字符串。最多 1,073,741,824 个字符。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>text</td>
<td>可变长度的字符串。最多 2GB 字符数据。</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<h3>Unicode 字符串：</h3>
<table class="dataintable">
<tbody><tr>
<th>数据类型</th>
<th>描述</th>
<th>存储</th>
</tr>
<tr>
<td>nchar(n)</td>
<td>固定长度的 Unicode 数据。最多 4,000 个字符。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>nvarchar(n)</td>
<td>可变长度的 Unicode 数据。最多 4,000 个字符。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>nvarchar(max)</td>
<td>可变长度的 Unicode 数据。最多 536,870,912 个字符。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>ntext</td>
<td>可变长度的 Unicode 数据。最多 2GB 字符数据。</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<h3>Binary 类型：</h3>
<table class="dataintable">
<tbody><tr>
<th>数据类型</th>
<th>描述</th>
<th>存储</th>
</tr>
<tr>
<td>bit</td>
<td>允许 0、1 或 NULL</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>binary(n)</td>
<td>固定长度的二进制数据。最多  8,000 字节。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>varbinary(n)</td>
<td>可变长度的二进制数据。最多  8,000 字节。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>varbinary(max)</td>
<td>可变长度的二进制数据。最多  2GB 字节。</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>image</td>
<td>可变长度的二进制数据。最多 2GB。</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<h3>Number 类型：</h3>
<table class="dataintable">
<tbody><tr>
<th>数据类型</th>
<th>描述</th>
<th>存储</th>
</tr>
<tr>
<td>tinyint</td>
<td>允许从 0 到 255 的所有数字。</td>
<td>1 字节</td>
</tr>
<tr>
<td>smallint</td>
<td>允许从 -32,768  到 32,767 的所有数字。</td>
<td>2 字节</td>
</tr>
<tr>
<td>int</td>
<td>允许从 -2,147,483,648 到 2,147,483,647 的所有数字。</td>
<td>4 字节</td>
</tr>
<tr>
<td>bigint</td>
<td>允许介于 -9,223,372,036,854,775,808 和 9,223,372,036,854,775,807 之间的所有数字。</td>
<td>8 字节</td>
</tr>
<tr>
<td>decimal(p,s)</td>
<td>
<p>固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。</p>
<p>p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。</p>
<p>s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。</p>
</td>
<td>5-17 字节</td>
</tr>
<tr>
<td>numeric(p,s)</td>
<td>
<p>固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。</p>
<p>p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。</p>
<p>s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。</p>
</td>
<td>5-17 字节</td>
</tr>
<tr>
<td>smallmoney</td>
<td>介于 -214,748.3648 和 214,748.3647 之间的货币数据。</td>
<td>4 字节</td>
</tr>
<tr>
<td>money</td>
<td>介于 -922,337,203,685,477.5808 和 922,337,203,685,477.5807 之间的货币数据。</td>
<td>8 字节</td>
</tr>
<tr>
<td>float(n)</td>
<td>
从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。
参数 n 指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。
</td>
<td>4 或 8 字节</td>
</tr>
<tr>
<td>real</td>
<td>从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。</td>
<td>4 字节</td>
</tr>
</tbody></table>
<h3>Date 类型：</h3>
<table class="dataintable">
<tbody><tr>
<th>数据类型</th>
<th>描述</th>
<th>存储</th>
</tr>
<tr>
<td>datetime</td>
<td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。</td>
<td>8 bytes</td>
</tr>
<tr>
<td>datetime2</td>
<td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。</td>
<td>6-8 bytes</td>
</tr>
<tr>
<td>smalldatetime</td>
<td>从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。</td>
<td>4 bytes</td>
</tr>
<tr>
<td>date</td>
<td>仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。</td>
<td>3 bytes</td>
</tr>
<tr>
<td>time</td>
<td>仅存储时间。精度为 100 纳秒。</td>
<td>3-5 bytes</td>
</tr>
<tr>
<td>datetimeoffset</td>
<td>与 datetime2 相同，外加时区偏移。</td>
<td>8-10 bytes</td>
</tr>
<tr>
<td>timestamp</td>
<td>存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<h3>其他数据类型：</h3>
<table class="dataintable">
<tbody><tr>
<th>数据类型</th>
<th>描述</th>
</tr>
<tr>
<td>sql_variant</td>
<td>存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。</td>
</tr>
<tr>
<td>uniqueidentifier</td>
<td>存储全局标识符 (GUID)。</td>
</tr>
<tr>
<td>xml</td>
<td>存储 XML 格式化数据。最多 2GB。</td>
</tr>
<tr>
<td>cursor</td>
<td>存储对用于数据库操作的指针的引用。</td>
</tr>
<tr>
<td>table</td>
<td>存储结果集，供稍后处理。</td></tr></tbody></table></div>
</div>
    ]]></string>
    <string name="chapter_content_one_2">
        <![CDATA[
            <h2>创建数据库</h2><p>这样做就可以创建一个数据库：</p>CREATE DATABASE 数据库名称<h2>创建一个表</h2><p>这样做就可以创建一个数据库中的表：</p><p>CREATE TABLE 表名称
(
列名称1 数据类型,</p><p>&nbsp;列名称2 数据类型,</p><p>&nbsp;.......</p><p>&nbsp;)</p><h3>实例</h3><p>本例演示如何创建名为 "Person" 的表，有四个列。列名是："LastName"、"FirstName"、"Address" 以及 "Age"：</p><p>CREATE TABLE Person
(</p><p>&nbsp;LastName varchar,</p><p>&nbsp;FirstName varchar,</p><p>&nbsp;Address varchar,</p><p>&nbsp;Age int
)</p><p>这个例子演示如何为某些列定义长度的最大值：</p><p>CREATE TABLE Person
(</p><p>&nbsp;LastName varchar(30),</p><p>&nbsp;FirstName varchar,</p><p>&nbsp;Address varchar,</p><p>&nbsp;Age int(3)
)
</p><p>数据类型（data_type）规定了列可容纳何种数据类型。下面的表格包含了SQL中最常用的数据类型：</p><h2>创建索引</h2><p>索引被创建于已有的表中，它可使对行的定位更快速更有效。可以在表格的一个或者多个列上创建索引，每个索引都会被起个名字。用户无法看到索引，它们只能被用来加速查询。</p><p class="note"><span>注释：</span>更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常用于搜索的列上面创建索引。</p><h3>唯一的索引 (Unique Index)</h3><p>在表格上面创建某个一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。</p>CREATE UNIQUE INDEX 索引名称
ON 表名称 (列名称)
<p>"列名称" 规定你需要索引的列。</p><h3>简单的索引</h3><p>在表上创建一个简单的索引。当我们省略关键词 UNIQUE 时，就可以使用重复的值。</p>CREATE INDEX 索引名称
ON 表名称 (列名称)
<p>"列名称" 规定你需要索引的列。</p><h3>实例</h3><p>本例会创建一个简单的索引，名为 "PersonIndex"，在 Person 表的 LastName 字段：</p><p>CREATE INDEX PersonIndex</p><p>ON Person (LastName)&nbsp;</p><p>如果您希望以<span>降序</span>索引某个列中的值，您可以在列名称之后添加保留字&nbsp;<span>DESC</span>：</p><p>CREATE INDEX PersonIndex</p><p>ON Person (LastName DESC)&nbsp;</p><p>假如您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：</p><p>CREATE INDEX PersonIndex</p><p>ON Person (LastName, FirstName)</p>
        ]]>
    </string>
    <string name="chapter_content_one_3">
        <![CDATA[
                <h2>SQL SELECT 语句</h2><p>SELECT 语句用于从表中选取数据。</p><p>结果被存储在一个结果表中（称为结果集）。</p><h3>SQL SELECT 语法</h3>SELECT 列名称 FROM 表名称<p>以及：</p>SELECT * FROM 表名称<p class=\"note\">注释：SQL 语句对大小写不敏感。SELECT 等效于 select。</p><h2>SQL SELECT 实例</h2><p>如需获取名为 \"LastName\" 和 \"FirstName\" 的列的内容（从名为 \"Persons\" 的数据库表），请使用类似这样的 SELECT 语句：</p>SELECT LastName,FirstName FROM Persons <br><h2>SQL SELECT * 实例</h2><p>现在我们希望从 \"Persons\" 表中选取所有的列。</p><p>请使用符号 * 取代列的名称，就像这样：</p>SELECT * FROM Persons<p class=\"tip\">提示：星号（*）是选取所有列的快捷方式。</p><h3><br></h3><p></p><p>WHERE 子句用于规定选择的标准。</p><h2>WHERE 子句</h2><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。</p><h3>语法</h3>SELECT 列名称 FROM 表名称 WHERE 列 运算符 值<p>下面的运算符可在 WHERE 子句中使用：</p><table class=\"dataintable\"><tbody><tr><th>操作符</th><th>描述</th></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr></tbody></table><p class=\"note\">注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。</p><h2>使用 WHERE 子句</h2><p>如果只希望选取居住在城市 \"Beijing\" 中的人，我们需要向 SELECT 语句添加 WHERE 子句：</p>SELECT * FROM Persons WHERE City=&#39;Beijing&#39;<br><h2>引号的使用</h2><p>请注意，我们在例子中的条件值周围使用的是单引号。</p><p>SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。</p><h3>文本值：</h3>这是正确的： SELECT * FROM Persons WHERE FirstName=&#39;Bush&#39;  这是错误的： SELECT * FROM Persons WHERE FirstName=Bush <h3>数值：</h3>这是正确的： SELECT * FROM Persons WHERE Year&gt;1965  这是错误的： SELECT * FROM Persons WHERE Year&gt;&#39;1965&#39;<br><h2>INSERT INTO 语句</h2><p>INSERT INTO 语句用于向表格中插入新的行。</p><h3>语法</h3>INSERT INTO 表名称 VALUES (值1, 值2,....)<p>我们也可以指定所要插入数据的列：</p>INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)<h2>SQL 语句：<br></h2>INSERT INTO Persons VALUES (&#39;Gates&#39;, &#39;Bill&#39;, &#39;Xuanwumen 10&#39;, &#39;Beijing&#39;)<br><h2>在指定的列中插入数据</h2><h3>SQL 语句：<br></h3>INSERT INTO Persons (LastName, Address) VALUES (&#39;Wilson&#39;, &#39;Champs-Elysees&#39;)<br><h2>Update 语句</h2><p>Update 语句用于修改表中的数据。</p><h3>语法：</h3>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值<h2>更新某一行中的一个列</h2><p>我们为 lastname 是 \"Wilson\" 的人添加 firstname：</p>UPDATE Person SET FirstName = &#39;Fred&#39; WHERE LastName = &#39;Wilson&#39; <br><h2>更新某一行中的若干列</h2><p>我们会修改地址（address），并添加城市名称（city）：</p>UPDATE Person SET Address = &#39;Zhongshan 23&#39;, City = &#39;Nanjing&#39; WHERE LastName = &#39;Wilson&#39;<br><h2><br></h2><h2>DELETE 语句</h2><p>DELETE 语句用于删除表中的行。</p><h3>语法</h3>DELETE FROM 表名称 WHERE 列名称 = 值<h2>删除某行</h2><p>\"Fred Wilson\" 会被删除：</p>DELETE FROM Person WHERE LastName = &#39;Wilson&#39; <br><h2>删除所有行</h2><p>可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：</p>DELETE FROM table_name<p>或者：</p>DELETE * FROM table_name<br>

        ]]>
    </string>

    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>

</resources>
