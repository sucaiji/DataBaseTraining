<!DOCTYPE HTML>
<html>
<head>
    <link href="css/style.css" type="text/css" rel="stylesheet">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body><b><p>转自http://blog.csdn.net/xiangminjing/article/details/5922325</p></b>
<p><strong>数据库并发控制</strong></p>
<p></p>
<div class="bct fc05 fc11 nbw-blog ztag js-fs2"><p><a
        href="http://img.blog.163.com/photo/tipWUBM6SeEvRUXsIhMAmQ==/5403193652938985216.jpg" target="_blank"><img
        src="http://img.blog.163.com/photo/tipWUBM6SeEvRUXsIhMAmQ==/5403193652938985216.jpg"/></a>&nbsp;</p>
    <p>&nbsp;</p>
    <p>1．&nbsp; 在数据库中为什么要并发控制？</p>
    <p>
        答：数据库是共享资源，通常有许多个事务同时在运行。当多个事务并发地存取数据库时就会产生同时读取和／或修改同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制。</p>
    <p>&nbsp;</p>
    <p>&nbsp;2 ．并发操作可能会产生哪几类数据不一致？用什么方法能避免各种不一致的情况？</p>
    <p>答：并发操作带来的数据不一致性包括三类：丢失修改、不可重复读和读“脏’夕数据。 ( l ）丢失修改（lost update ) 两个事务 Tl 和T2读入同一数据并修改，T2提交的结果破坏了（覆盖了） Tl 提交的结果，导致
        Tl 的修改被丢失。 ( 2 ）不可重复读（ Non 一 Repeatable Read ) 不可重复读是指事务 Tl 读取数据后，事务几执行更新操作，使 Tl 无法再现前一次读取结果。( 3 ）读“脏”数据（ Dirty
        Read ) 读“脏’夕数据是指事务 Tl 修改某一数据，并将其写回磁盘，事务几读取同一数据后， Tl 由于某种原因被撤销，这时 Tl
        已修改过的数据恢复原值，几读到的数据就与数据库中的数据不一致，则几读到的数据就为“脏”数据，即不正确的数据。避免不一致性的方法和技术就是并发控制。最常用的技术是封锁技术。也可以用其他技术，例如在分布式数据库系统中可以采用时间戳方法来进行并发控制。</p>
    <p>&nbsp;</p>
    <p>3 ．什么是封锁？基本的封锁类型有几种？试述它们的含义。</p>
    <p>答：封锁就是事务 T 在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务 T 就对该数据对象有了一定的控制，在事务 T
        释放它的锁之前，其他的事务不能更新此数据对象。封锁是实现并发控制的一个非常重要的技术。</p>
    <p>基本的封锁类型有两种：排它锁（ Exclusive Locks ，简称 x 锁）和共享锁 ( Share Locks，简称 S 锁）。排它锁又称为写锁。若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A
        ，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。这就保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A 。共享锁又称为读锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读
        A但不能修改 A ，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这就保证了其他事务可以读 A ，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。</p>
    <p>&nbsp;</p>
    <p>4 ．如何用封锁机制保证数据的一致性？</p>
    <p>答： DBMS 在对数据进行读、写操作之前首先对该数据执行封锁操作，例如下图中事务 Tl 在对 A 进行修改之前先对 A 执行 xock ( A ) ，即对 A 加 x 锁。这样，当几请求对 A 加 x
        锁时就被拒绝，几只能等待 Tl 释放 A 上的锁后才能获得对 A 的 x 锁，这时它读到的 A 是 Tl 更新后的值，再按此新的 A 值进行运算。这样就不会丢失 Tl 的更新。</p>
    <p><a href="http://img.blog.163.com/photo/mBk8VVL2OXef8SPr9Bcu1w==/2018457057992860102.jpg" target="_blank"><img
            src="http://img.blog.163.com/photo/mBk8VVL2OXef8SPr9Bcu1w==/2018457057992860102.jpg"/></a></p>
    <p>DBMS 按照一定的封锁协议，对并发操作进行控制，使得多个并发操作有序地执行，就可以避免丢失修改、不可重复读和读“脏’夕数据等数据不一致性。</p>
    <p>&nbsp;</p>
    <p>5 ．什么是活锁？什么是死锁？</p>
    <p>答：</p>
    <p><a href="http://img.blog.163.com/photo/zDH5mZ2X9nU_kvgpY714rA==/5403193652938985215.jpg" target="_blank"><img
            src="http://img.blog.163.com/photo/zDH5mZ2X9nU_kvgpY714rA==/5403193652938985215.jpg"/></a></p>
    <p>如果事务 Tl 封锁了数据 R ，事务几又请求封锁 R ，于是几等待。几也请求封锁 R ，当 Tl 释放了 R 上的封锁之后系统首先批准了几的请求，几仍然等待。然后几又请求封锁 R ，当几释放了 R
        上的封锁之后系统又批准了几的请求 … … 几有可能永远等待，这就是活锁的情形。活锁的含义是该等待事务等待时间太长，似乎被锁住了，实际上可能被激活。如果事务 Tl 封锁了数据 Rl ，几封锁了数据凡，然后 Tl
        又请求封锁几，因几已封锁了几，于是 Tl 等待几释放几上的锁。接着几又申请封锁 Rl ，因 Tl 已封锁了 Rl ，几也只能等待 Tl 释放 Rl 上的锁。这样就出现了 Tl 在等待几，而几又在等待 T ｝的局面， T
        ｝和几两个事务永远不能结束，形成死锁。</p>
    <p><a href="http://img.blog.163.com/photo/tipWUBM6SeEvRUXsIhMAmQ==/5403193652938985216.jpg" target="_blank"><img
            src="http://img.blog.163.com/photo/tipWUBM6SeEvRUXsIhMAmQ==/5403193652938985216.jpg"/></a></p>
    <p>&nbsp;</p>
    <p>6 ．试述活锁的产生原因和解决方法。</p>
    <p>
        答：活锁产生的原因：当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁。避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。</p>
    <p>&nbsp;</p>
    <p>11 ．请给出检测死锁发生的一种方法，当发生死锁后如何解除死锁？</p>
    <p>答：数据库系统一般采用允许死锁发生， DBMS 检测到死锁后加以解除的方法。 DBMS 中诊断死锁的方法与<a href="http://lib.csdn.net/base/operatingsystem"
                                                               class="replace_word" title="操作系统知识库"
                                                               target="_blank">操作系统</a>类似，一般使用超时法或事务等待图法。超时法是：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但有可能误判死锁，事务因其他原因长时间等待超过时限时，系统会误认为发生了死锁。若时限设置得太长，又不能及时发现死锁发生。
        DBMS 并发控制子系统检测到死锁后，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有锁，使其他事务得以继续运行下去。当然，对撤销的事务所执行的数据修改操作必须加以恢复。</p>
    <p>&nbsp;</p>
    <p>&nbsp;12 ．什么样的并发调度是正确的调度？</p>
    <p>答：可串行化（ Serializable ）的调度是正确的调度。可串行化的调度的定义：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行执行它们时的结果相同，称这种调度策略为可串行化的调度。</p>
    <p>&nbsp;</p>
    <p>9 ．设 Tl ，几，几是如下的 3 个事务：</p>
    <p>Tl ：A : = A + 2 ;</p>
    <p>T2：A : = A * 2 ;</p>
    <p>T3：A : = A **2 ; ( A &lt;-A*A）</p>
    <p>设 A 的初值为 0 。</p>
    <p>( l ）若这 3 个事务允许并行执行，则有多少可能的正确结果，请一一列举出来。</p>
    <p>答 ：A 的最终结果可能有 2 、 4 、 8 、 16 。因为串行执行次序有 Tl T2T3、 Tl T3T2、T2T1T3、T2T3Tl 、T3T1T2、T3T2 Tl 。对应的执行结果是 16 、 8 · 4 · 2 ·
        4 · 2 。</p>
    <p>( 2 ）请给出一个可串行化的调度，并给出执行结果</p>
    <p>答：</p>
    <p><a href="http://img.blog.163.com/photo/slTvs_S9oy-zosSUJmbIzA==/2018457057992860109.jpg" target="_blank"><img
            src="http://img.blog.163.com/photo/slTvs_S9oy-zosSUJmbIzA==/2018457057992860109.jpg"/></a></p>
    <p>&nbsp;</p>
    <p>最后结果 A 为 16 ，是可串行化的调度。</p>
    <p>( 3 ）请给出一个非串行化的调度，并给出执行结果。</p>
    <p>答：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
            href="http://img.blog.163.com/photo/4mLQE4CvuNznBpZD1oikIA==/2018457057992860112.jpg" target="_blank"><img
            src="http://img.blog.163.com/photo/4mLQE4CvuNznBpZD1oikIA==/2018457057992860112.jpg"/></a></p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后结果 A 为 0 ，为非串行化的调度。</p>
    <p>( 4 ）若这 3 个事务都遵守两段锁协议，请给出一个不产生死锁的可串行化调度。</p>
    <p>答：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
            href="http://img.blog.163.com/photo/j_pzUdXqTSiSG5ExpDAkEg==/2018457057992860115.jpg" target="_blank"><img
            src="http://img.blog.163.com/photo/j_pzUdXqTSiSG5ExpDAkEg==/2018457057992860115.jpg"/></a></p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp; ( 5 ）若这 3 个事务都遵守两段锁协议，请给出一个产生死锁的调度。</p>
    <p>答：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
            href="http://img.blog.163.com/photo/tPuc4Z923FNWXhmDVhHsXA==/1489002626800190087.jpg" target="_blank"><img
            src="http://img.blog.163.com/photo/tPuc4Z923FNWXhmDVhHsXA==/1489002626800190087.jpg"/></a></p>
    <p>&nbsp;</p>
    <p>11．试证明，若并发事务遵守两段锁协议，则对这些事务的并发调度是可串行化的。</p>
    <p>证明：首先以两个并发事务 Tl 和T2为例，存在多个并发事务的情形可以类推。根据可串行化定义可知，事务不可串行化只可能发生在下列两种情况：</p>
    <p>&nbsp;( l ）事务 Tl 写某个数据对象 A ，T2读或写 A ;</p>
    <p>( 2 ）事务 Tl 读或写某个数据对象 A ，T2写 A 。</p>
    <p>下面称 A 为潜在冲突对象。</p>
    <p>设 Tl 和T2访问的潜在冲突的公共对象为{A1，A2 … ， An ｝。不失一般性，假设这组潜在冲突对象中 X ＝(A 1 , A2 ， … ， Ai ｝均符合情况 1 。 Y ＝{A i + 1 ， … ， An
        ｝符合所情况（ 2 ）。</p>
    <p>VX ∈ x , Tl 需要 XlockX ①</p>
    <p>T2 需要 Slockx 或 Xlockx ②</p>
    <p>&nbsp;1 ）如果操作 ① 先执行，则 Tl 获得锁，T2等待</p>
    <p>由于遵守两段锁协议， Tl 在成功获得 x 和 Y 中全部对象及非潜在冲突对象的锁后，才会释放锁。</p>
    <p>这时如果存在 w ∈ x 或 Y ，T2已获得 w 的锁，则出现死锁；否则， Tl 在对 x 、 Y 中对象全部处理完毕后，T2才能执行。这相当于按 Tl 、T2的顺序串行执行，根据可串行化定义， Tl
        和几的调度是可串行化的。</p>
    <p>2 ）操作 ② 先执行的情况与（ l ）对称因此，若并发事务遵守两段锁协议，在不发生死锁的情况下，对这些事务的并发调度一定是可串行化的。证毕。</p>
    <p>&nbsp;</p>
    <p>12 ．举例说明，对并发事务的一个调度是可串行化的，而这些并发事务不一定遵守两段锁协议。</p>
    <p>答：</p>
    <p>&nbsp;<a href="http://img.blog.163.com/photo/_Sq7u9M8EMlOxXoFZLP52A==/1451003504944426858.jpg"
                target="_blank"><img
            src="http://img.blog.163.com/photo/_Sq7u9M8EMlOxXoFZLP52A==/1451003504944426858.jpg"/></a></p>
    <p>13 ．为什么要引进意向锁？意向锁的含义是什么？</p>
    <p>答：引进意向锁是为了提高封锁子系统的效率。该封锁子系统支持多种封锁粒度。原因是：在多粒度封锁方法中一个数据对象可能以两种方式加锁 ―
        显式封锁和隐式封锁。因此系统在对某一数据对象加锁时不仅要检查该数据对象上有无（显式和隐式）封锁与之冲突，还要检查其所有上级结点和所有下级结点，看申请的封锁是否与这些结点上的（显式和隐式）封锁冲突，显然，这样的检查方法效率很低。为此引进了意向锁。意向锁的含义是：对任一结点加锁时，必须先对它的上层结点加意向锁。例如事务
        T 要对某个元组加 X 锁，则首先要对关系和数据库加 ix 锁。换言之，对关系和数据库加 ix 锁，表示它的后裔结点 ― 某个元组拟（意向）加 X
        锁。引进意向锁后，系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了。例如，事务 T 要对关系 R 加 X 锁时，系统只要检查根结点数据库和 R 本身是否已加了不相容的锁（如发现已经加了 ix ，则与 X
        冲突），而不再需要搜索和检查 R 中的每一个元组是否加了 X 锁或 S 锁。</p>
    <p>&nbsp;</p>
    <p>14 ．试述常用的意向锁： IS 锁、 ix 锁、 SIX 锁，给出这些锁的相容矩阵。</p>
    <p>答： IS锁：如果对一个数据对象加 IS 锁，表示它的后裔结点拟（意向）加 S 锁。例如，要对某个元组加 S 锁，则要首先对关系和数据库加 IS 锁</p>
    <p>IX 锁：如果对一个数据对象加 ix 锁，表示它的后裔结点拟（意向功口 X 锁。例如，要对某个元组加 X 锁，则要首先对关系和数据库加 ix 锁。</p>
    <p>SIX 锁：如果对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁，即 SIX = S + IX 。</p>
    <p>相容矩阵：</p>
    <p>&nbsp;<a href="http://img.blog.163.com/photo/hCviLgrsmpJwmq9BpQDaRg==/611363649416538133.jpg"
                target="_blank"><img
            src="http://img.blog.163.com/photo/hCviLgrsmpJwmq9BpQDaRg==/611363649416538133.jpg"/></a></p>
    <p>15 ．理解并解释下列术语的含义：封锁、活锁、死锁、排它锁、共享锁、并发事务的调度、可串行化的调度、两段锁协议。</p>
    <p>答：（略，已经在上面有关习题中解答）</p>
    <p>&nbsp;</p>
    <p>16 ．试述你了解的某一个实际的 DBMS 产品的并发控制机制。</p>
    <p>答：（略，参见简单介绍了有关&nbsp;<a href="http://lib.csdn.net/base/oracle" class="replace_word" title="Oracle知识库"
                              target="_blank">Oracle</a>&nbsp;的并发控制机制。</p></div>
</body>
</html>