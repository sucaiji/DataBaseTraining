http://blog.csdn.net/liupeng900605/article/details/7095312<div><strong>关系数据库规范化理论</strong></div><div>一个关系数据库由一组关系模式组成，一个关系由一组属性名组成，关系数据库设计就是如何把已给定的相互关联的一组属性名分组，并把每一组属性名组织成关系的问题。</div><div><strong>1、关系规范化的作用</strong></div><div>所谓规范化，就是用形式更为简洁、结构更加规范的关系模式取代原有关系的过程。</div><div><strong>2、函数依赖</strong></div><div><strong>2.1、属性间的联系</strong></div><div>实体间的联系有两类：一类是实体与实体之间的联系；另一类是实体内部各属性间的联系。</div><div>属性间的联系可分为以下三类：</div><div><strong>（1）一对一联系（1∶1）</strong></div><div>以职工模式为例：职工（职工号，姓名，职称，部门）。如果该企业（或单位）中职工无重名，则属性职工号与姓名之间是1∶1联系。一个职工号唯一地决定一个姓名，一个姓名也可决定唯一的职工号。</div><div>设X、Y是关系R的两个属性（集）。如果对于X中的任一具体值，Y中至多有一个值与之对应，且反之亦然，则称X、Y两属性间是一对一联系。</div><div><strong>（2）一对多联系（1∶ m）</strong></div><div>在职工模式中，职工号和职称间是一对多联系。一个职工号只对应一种职称（如胡一民只能对应工程师），但一种职称却可对应多个职工号（如工程师可对应多名职工）。</div><div>设X、Y是关系R的两个属性（集）。如果对于X中的任一具体值，Y中至多有一个值与之对应，而Y中的一个值却可以和X中的n个值相对应，则称Y对X是一对多联系。</div><div><strong>（3）多对多联系（m∶ m）</strong></div><div>在职工模式中，职称和部门之间是多对多联系。一种职称可分布在多个部门中（如每一个部门中均可有工程师），而一个部门中也可有多个职称。</div><div>设X、Y是关系R的两个属性（集）。如果对于X中的任一具体值，Y中有m个值与之对应，而Y中的一个值也可以和X中的n个值相对应，则称Y对X是多对多联系。</div><div><span>上述属性间的三种联系实际上是属性值之间相互依赖又相互制约的反映，称为属性间的数据依赖。</span></div><div><span>数据依赖共有三种：函数依赖（</span><span>FunctionalDependency</span><span>，简称</span><span>FD</span><span>）、多值依赖（</span><span>Multiva-luedDependency</span><span>，简称</span><span>MVD</span><span>）和连接依赖（</span><span>JoinDependency</span><span>，简称</span><span>JD</span><span>），其中最重要的是函数依赖和多值依赖。</span></div><div><strong>2.2、函数依赖</strong></div><div>函数依赖是属性之间的一种联系。假设给定一个属性的值，就可以唯一确定（查到）另一个属性的值。</div><div><span>定义：所谓函数依赖是指在关系</span><span>R</span><span>中，</span><span>X</span><span>、</span><span>Y</span><span>为</span><span>R</span><span>的两个属性或属性组，如果对于</span><span>R</span><span>的任一关系</span><span>r</span><span>都存在：对于</span><span>X</span><span>的每一个具体值，</span><span>Y&nbsp;</span><span>都只有一个具体值与之对应，则称属性</span><span>Y</span><span>函数依赖于属性</span><span>X</span><span>。或者说，属性</span><span>X</span><span>函数决定属性</span><span>Y</span><span>，记作</span><span>X</span><span>à</span><span>Y</span><span>。</span>其中X叫决定因素，Y叫被决定因素。当Y是X的子集时，称为平凡函数依赖。由于平凡函数依赖总是成立的，因此，若不作特殊声明，本书后面提到的函数依赖，都不包含平凡函数依赖。</div><div>此定义可简单表述为：如果属性X的值决定属性Y的值，那么属性Y函数依赖于属性X。</div><div>前面讨论的属性间的三种联系，并不是每一种联系中都存在函数依赖。</div><div>（1）如果两属性集X、Y 间是1∶ 1联系，则存在函数依赖：Xß&gt;Y。</div><div>（2）如果两属性集X、Y间是m∶ 1联系，则存在函数依赖：XàY。</div><div>（3）如果两属性集X、Y间是m∶ n联系，则不存在函数依赖。</div><div><strong>2.3、码的定义</strong></div><div><span>定义</span><span>设</span><span>&nbsp;K&nbsp;</span><span>是关系模式</span><span>&nbsp;R</span><span>（</span><span>U</span><span>，</span><span>F</span><span>）中的属性或属性组，</span><span>K</span><span>′是</span><span>&nbsp;K&nbsp;</span><span>的任一真子集。若</span><span>K</span><span>à</span><span>U</span><span>，而不存在</span><span>K</span><span>′</span><span>à</span><span>U</span><span>，则</span><span>K</span><span>为</span><span>R</span><span>的候选码（</span><span>CandidateKey</span><span>），简称为码。</span></div><div>· 若候选码多于一个，则选定其中的一个为主码（PrimaryKey）；</div><div>· 包含在任一候选码中的属性，叫做主属性（PrimeAttribute）；</div><div>· 不包含在任何候选码中的属性称为非主属性（NonprimeAttribute）或非码属性（Non KeyAttribute）；</div><div>· 关系模式中，最简单的情况，单个属性是码，称为单码（SingleKey）；最极端的情况，整个属性组是码，称为全码（All Key）。</div><div>定义 设有两个关系模式R和S，X是R的属性或属性组，并且X不是R的码，但X是S的码（或与S的码意义相同），则称X是R的外部码（ForeignKey），简称外码。</div><div><strong>2.4、函数依赖和码的唯一性</strong></div><div>码是由一个或多个属性组成的可唯一标识元组的最小属性组。码在关系中总是唯一的，即码函数决定关系中的其他属性。因此，一个关系中，码值总是唯一的（如果码的值重复，则整个元组都会重复）。否则，违反实体完整性规则。</div><div>与码的唯一性不同，在关系中，一个函数依赖的决定因素可能是唯一的，也可能不是唯一的。如果我们知道A决定B，且A和B在同一关系中，但我们仍无法知道A是否能决定除B以外的其他所有属性，所以无法知道A在关系中是否是唯一的。</div><div><strong>3、关系模式的规范化</strong></div><div><strong>3.1、关系模式的规范化</strong></div><div>当一个关系中的所有分量都是不可分的数据项时，该关系是规范化的</div><div>关系按其规范化程度从低到高可分为5级范式，分别称为1NF、2NF、3NF（BCNF）、4NF、5NF。规范化程度较高者必是较低者的子集</div><div><strong>3.2、第一范式（1NF）</strong></div><div><span>定义</span><span>如果关系模式</span><span>R</span><span>中不包含多值属性，则</span><span>R</span><span>满足第一范式，简称</span><span>1NF</span><span>（</span><span>FirstNor-malForm</span><span>），记作</span><span>R</span><span>属于</span><span>1NF</span><span>。</span></div><div>1NF是规范化的最低要求，不满足1NF的关系是非规范化关系</div><div><strong>3.3、第二范式（2NF）</strong></div><div><span>定义</span><span>设</span><span>X</span><span>、</span><span>Y</span><span>是关系</span><span>R</span><span>的两个不同的属性或属性组，且</span><span>X</span><span>属于</span><span>Y</span><span>。如果存在</span><span>X</span><span>的某一个真子集</span><span>X</span><span>′，使</span><span>X</span><span>′属于成立，则称</span><span>Y</span><span>部分函数依赖于</span><span>X</span><span>，反之，则称</span><span>Y</span><span>完全函数依赖于</span><span>X</span><span>，</span></div><div><span>定义</span><span>如果一个关系</span><span>R</span><span>属于</span><span>1NF</span><span>，且它的所有非主属性都完全函数依赖于</span><span>R</span><span>的任一候选码，则</span><span>R</span><span>属于第二范式，记作</span><span>R</span><span>属于</span><span>2NF</span><span>。</span></div><div>推论：如果关系模式R‑1NF，且它的每一个候选码都是单码，则R属于2NF。</div><div><strong>3.4、第三范式（3NF）</strong></div><div><span>定义</span><span>在关系</span><span>R</span><span>中，</span><span>X</span><span>、</span><span>Y</span><span>、</span><span>Z</span><span>是</span><span>R</span><span>的三个不同的属性或属性组，如果</span><span>X</span><span>à</span><span>Y</span><span>，</span><span>Y</span><span>à</span><span>Z</span><span>，但</span><span>Y/--&gt;X</span><span>且</span><span>Y</span><span>不是</span><span>X</span><span>的子集，则称</span><span>Z</span><span>传递依赖于</span><span>X</span><span>。</span></div><div><span>定义</span><span>如果关系模式</span><span>R</span><span>属于</span><span>2NF</span><span>，且它的每一个非主属性都不传递依赖于任何候选码，则称</span><span>R</span><span>是第三范式，记作</span><span>R</span><span>属于</span><span>3NF</span><span>。</span></div><div>推论1&nbsp;如果关系模式R属于1NF，且它的每一个非主属性既不部分依赖，也不传递依赖于任何候选码，则R属于3NF。</div><div>推论2&nbsp;不存在非主属性的关系模式一定为3NF。</div><div><strong>3.5、改进的3NF——BCNF</strong></div><div>定义 设关系模式R（U，F）属于NF，若F的任一函数依赖XàY（Y不是X的子集）中X都包含了R的一个码，则称R属于BCNF。</div><div>换言之，在关系模式R中，如果每一个决定因素都包含码，则R属于BCNF。</div><div>由BCNF的定义可以得到以下推论：如果R属于BCNF，则</div><div>· R中所有非主属性对每一个码都是完全函数依赖；</div><div>· R中所有主属性对每一个不包含它的码，都是完全函数依赖；</div><div>· R中没有任何属性完全函数依赖于非码的任何一组属性。</div><div>定理：如果R属于BCNF，则R属于3NF一定成立。</div><div>一个关系模式如果达到了BCNF，那么在函数依赖范围内，它已实现了彻底的分离，消除了数据冗余、插入和删除异常。</div><div><strong>4、多值依赖和第四范式</strong></div><div>定义 设R（U）是属性集U上的一个关系模式，X、Y、Z是U的子集，且Z=U-X-Y。如果对R（U）的任一关系r，给定一对（x，z）值，都有一组Y值与之对应，这组Y值仅仅决定于x值而与z值无关。称Y多值依赖于X，或X多值决定Y，记作XààY。</div><div>定义中如果Z为空集，则称XààY为平凡的多值依赖，否则为非平凡多值依赖。</div><div>定义 如果关系模式R属于1NF，对于R的每个非平凡的多值依赖XààY（Y不是X的子集），X含有码，则称R是第四范式，即R属于4NF。</div><div>一个关系模式如果属于4NF，则一定属于BCNF，但一个BCNF的关系模式不一定是4NF的，R中所有的非平凡多值依赖实际上是函数依赖。</div><div><strong>5、关系的规范化度</strong></div><div>关系规范化的目的是解决关系模式中存在的数据冗余、插入和删除异常、更新繁琐等问题。其基本思想是消除数据依赖中的不合适部分，使各关系模式达到某种程度的分离，使一个关系描述一个概念、一个实体或实体间的一种联系。因此，规范化的实质是概念的单一化。</div><div>规范化的基本原则是：由低到高，逐步规范，权衡利弊，适可而止。通常，以满足第三范式为基本要求。</div><div>把一个非规范化的数据结构转换成第三范式，一般经过以下几步：</div><div>（1）把该结构分解成若干个属于第一范式的关系。</div><div>（2）对那些存在组合码，且有非主属性部分函数依赖的关系必须继续分解，使所得关系都属于第二范式。</div><div>（3）若关系中有非主属性传递依赖于码，则继续分解之，使得关系都属于第三范式。</div><div>关系模式的规范化过程是通过投影分解实现的，即用投影运算把一个模式分解成若干个高一级的关系模式。这种投影分解不是唯一的。</div>